triplerush {

  number-of-nodes = 4

  max-buffer-per-query = 100000

  akka {
    log-dead-letters = 100
    log-dead-letters-during-shutdown = off
    loglevel = WARNING

    extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]

    actor {
      provider = "akka.cluster.ClusterActorRefProvider"
      
      serializers {
        proto = "akka.remote.serialization.ProtobufSerializer"
        kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
      }

      serialization-bindings {
        "com.google.protobuf.Message" = proto
        "[I" = kryo
        "[[I" = kryo
        "akka.stream.impl.fusing.ActorGraphInterpreter$BoundarySubscriber" = kryo
        "com.signalcollect.triplerush.index.Index$AddEdge" = kryo
        "com.signalcollect.triplerush.index.Index$EdgeAdded$" = kryo
        "com.signalcollect.triplerush.query.QueryExecutionHandler$BindingsForQuery" = kryo
        "com.signalcollect.triplerush.query.QueryExecutionHandler$Tickets" = kryo
        "scala.collection.immutable.Vector" = kryo
        "com.signalcollect.triplerush.query.QueryExecutionHandler$RegisterForQuery" = kryo
        "com.signalcollect.triplerush.query.QueryExecutionHandler$RequestResultsForQuery" = kryo
        "akka.stream.actor.ActorPublisherMessage$Request" = kryo
        "com.signalcollect.triplerush.util.Streamer$Completed$" = kryo
        "com.signalcollect.triplerush.index.Outgoing" = kryo
        "com.signalcollect.triplerush.index.Index$GetAdjacencySets" = kryo
      }

      kryo {
        # Define mappings from a fully qualified class name to a numeric id.
        # Smaller ids lead to smaller sizes of serialized representations.
        #
        # This section is mandatory for idstartegy=explicit
        # This section is optional  for idstartegy=incremental
        # This section is ignored   for idstartegy=default
        #
        # The smallest possible id should start at 20 (or even higher), because
        # ids below it are used by Kryo internally e.g. for built-in Java and
        # Scala types
        mappings {
          "[I" = 20
          "[[I" = 21
          "com.signalcollect.triplerush.index.Index$AddEdge" = 22
          "com.signalcollect.triplerush.index.Index$EdgeAdded$" = 23
          "com.signalcollect.triplerush.query.QueryExecutionHandler$BindingsForQuery" = 24
          "com.signalcollect.triplerush.query.QueryExecutionHandler$Tickets" = 25
          "scala.collection.immutable.Vector" = 26
          "com.signalcollect.triplerush.TriplePattern" = 27
          "com.signalcollect.triplerush.query.QueryExecutionHandler$RegisterForQuery" = 28
          "com.signalcollect.triplerush.query.QueryExecutionHandler$RequestResultsForQuery" = 29
          "akka.stream.actor.ActorPublisherMessage$Request" = 30
          "com.signalcollect.triplerush.util.Streamer$Completed$" = 31
          "com.signalcollect.triplerush.index.Incoming" = 32
          "com.signalcollect.triplerush.index.Outgoing" = 33
          "com.signalcollect.triplerush.index.Index$GetAdjacencySets" = 34
        }

        # Possibles values for type are: graph or nograph
        # graph supports serialization of object graphs with shared nodes
        # and cyclic references, but this comes at the expense of a small
        # overhead nograph does not support object grpahs with shared nodes,
        # but is usually faster
        type = "graph"

        # Possible values for idstrategy are:
        # default, explicit, incremental
        #
        # default - slowest and produces bigger serialized representation.
        # Contains fully-qualified class names (FQCNs) for each class. Note
        # that selecting this strategy does not work in version 0.3.2, but
        # is available on master and from 0.3.3 onward.
        #
        # explicit - fast and produces compact serialized representation.
        # Requires that all classes that will be serialized are pre-registered
        # using the "mappings" and "classes" sections. To guarantee that both
        # sender and receiver use the same numeric ids for the same classes it
        # is advised to provide exactly the same entries in the "mappings"
        # section.
        #
        # incremental - fast and produces compact serialized representation.
        # Support optional pre-registering of classes using the "mappings"
        # and "classes" sections. If class is not pre-registered, it will be
        # registered dynamically by picking a next available id To guarantee
        # that both sender and receiver use the same numeric ids for the same
        # classes it is advised to pre-register them using at least the "classes" section.
        idstrategy = "explicit"

        # Define a default size for serializer pool
        # Try to define the size to be at least as big as the max possible
        # number of threads that may be used for serialization, i.e. max
        # number of threads allowed for the scheduler
        serializer-pool-size = 16

        # Define a default size for byte buffers used during serialization
        buffer-size = 4096

        # The serialization byte buffers are doubled as needed until they
        # exceed max-buffer-size and an exception is thrown. Can be -1
        # for no maximum.
        max-buffer-size = -1

        # If set, akka uses manifests to put a class name
        # of the top-level object into each message
        use-manifests = false

        # The transformations that have to be done during serialization.
        # Supported transformations: compression and encryption
        # accepted values(comma separated if multiple): off | lz4 | deflate | aes
        # Transformations occur in the order they are specified
        post-serialization-transformations = "lz4"

        # Log implicitly registered classes. Useful, if you want to know all
        # classes which are serialized. You can then use this information in
        # the mappings and/or classes sections
        implicit-registration-logging = on

        # If enabled, Kryo logs a lot of information about serialization process.
        # Useful for debugging and low-level tweaking
        kryo-trace = false

    }

    }

    remote {
      log-remote-lifecycle-events = off
      netty.tcp {
        hostname = "127.0.0.1"
        port = 0
      }
    }

    cluster {
      min-nr-of-members = ${triplerush.number-of-nodes}
    
      seed-nodes = ["akka.tcp://ClusterSystem@127.0.0.1:2551"]

      auto-down-unreachable-after = 10s

      metrics.enabled = off

      sharding {
        state-store-mode = ddata
        remember-entities = off
      }

    }

  }

}
